---

---

<div
    id="population-map-container"
    class="relative w-full h-[600px] md:h-[600px] flex items-center justify-center px-4 md:px-8 overflow-visible"
>
    <svg
        id="population-map"
        class="w-full h-full"
        style="background: transparent;"></svg>

    <!-- Tooltip -->
    <div
        id="map-tooltip"
        class="absolute pointer-events-none opacity-0 bg-[#0a0a0a]/80 text-white px-5 py-4 rounded-2xl border border-[#f2e25d]/20 backdrop-blur-2xl text-sm transition-all duration-300 z-50 shadow-2xl"
        style="box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);"
    >
        <div
            class="font-bold text-xl mb-2 text-[#f2e25d]"
            data-label="ward-name"
        >
        </div>
        <div class="text-zinc-300 text-base" data-label="population"></div>
    </div>
</div>

<script>
    import {
        select,
        geoPath,
        geoMercator,
        scaleSequential,
        interpolateRgb,
        easeCubicOut,
    } from "d3";
    import { wardsGeoJSON } from "./wardsData";

    function initMap() {
        console.log("ðŸ—ºï¸ Initializing map...");

        const container = document.getElementById("population-map-container");
        const svg = select("#population-map");
        const tooltip = select("#map-tooltip");

        if (!container) {
            console.error("Container not found!");
            return;
        }

        // High resolution for crisp 2D rendering
        const width = 2000;
        const height = 1600;

        // Clear existing content
        svg.selectAll("*").remove();

        // Set viewBox
        svg.attr("viewBox", `0 0 ${width} ${height}`).attr(
            "preserveAspectRatio",
            "xMidYMid meet",
        );

        // Manual projection configuration
        const centerLon = 86.88;
        const centerLat = 26.8;

        const projection = geoMercator()
            .center([centerLon, centerLat])
            .scale(450000) // Adjusted scale for new 2D dimensions
            .translate([width / 2, height / 2]);

        const pathGenerator = geoPath().projection(projection);

        // Main group
        const g = svg
            .append("g")
            .attr("class", "map-layers")
            .attr("transform", "translate(0, 0)"); // Centered flat map

        // Premium color scale - sophisticated gradient
        const populations = wardsGeoJSON.features.map(
            (f) => f.properties.total_population,
        );
        const minPop = Math.min(...populations);
        const maxPop = Math.max(...populations);

        // Clean gradient: slate-blue to bright cyan - matches dark background
        const colorScale = scaleSequential()
            .domain([minPop, maxPop])
            .interpolator(
                interpolateRgb(
                    "rgba(64, 52, 10, 0.7)", // Dark Golden/Olive
                    "rgba(242, 226, 93, 0.95)", // User Requested Gold #f2e25d
                ),
            );

        // Population-based opacity scale: least populous = 0.2, most populous = 0.9
        const opacityScale = scaleSequential()
            .domain([minPop, maxPop])
            .range([0.2, 0.9]);

        // Function to clean the path
        function cleanPath(pathString: string | null): string {
            if (!pathString) return "";
            const firstZIndex = pathString.indexOf("Z");
            if (firstZIndex === -1) return pathString;
            return pathString.substring(0, firstZIndex + 1);
        }

        // 1. Outer glow layer (for depth)
        const outerGlow = g
            .append("g")
            .attr("class", "glow-layer")
            .selectAll("path")
            .data(wardsGeoJSON.features)
            .join("path")
            .attr("d", (d) => cleanPath(pathGenerator(d as any)))
            .attr("fill", "none")
            .attr("stroke", "rgba(242, 226, 93, 0.15)") // Subtle Golden Glow
            .attr("stroke-width", 10)
            .attr("opacity", 0)
            .style("filter", "blur(15px)");

        // 2. Deep shadows (enhanced 3D)
        const shadows = g
            .append("g")
            .attr("class", "shadow-layer")
            .selectAll("path")
            .data(wardsGeoJSON.features)
            .join("path")
            .attr("d", (d) => cleanPath(pathGenerator(d as any)))
            .attr("fill", "rgba(0, 0, 0, 0.8)") // Pure black shadow
            .attr("opacity", 0)
            .attr("transform", "translate(8, 12)") // Deeper shadow offset
            .style("filter", "blur(8px)");

        // 3. Main Ward Layers (Glassmorphic)
        const wards = g
            .append("g")
            .attr("class", "wards-layer")
            .selectAll("path")
            .data(wardsGeoJSON.features)
            .join("path")
            .attr("d", (d) => cleanPath(pathGenerator(d as any)))
            .attr("fill", "none")
            .attr("stroke", "rgba(255, 255, 255, 0.9)") // Ultra-thick, bright white borders
            .attr("stroke-width", 8.0)
            .attr("class", "ward-path cursor-pointer")
            .style("pointer-events", "none") // Disable interaction until animation completes
            .attr("fill-opacity", 0)
            .style("backdrop-filter", "blur(10px)"); // Glass effect

        console.log("Ward paths created:", wards.size());

        // Animation Logic
        function runAnimation() {
            console.log("ðŸŽ¬ Running animation...");

            // Animate shadows first
            shadows
                .transition()
                .duration(800)
                .delay((d, i) => i * 150)
                .attr("opacity", 1);

            wards.each(function (d, i) {
                const node = this as SVGPathElement;
                const length = node.getTotalLength();
                const wardColor = colorScale(d.properties.total_population);

                select(node)
                    .attr("stroke-dasharray", length)
                    .attr("stroke-dashoffset", length)
                    .attr("stroke", "rgba(255, 255, 255, 1.0)") // High-contrast white stroke animation
                    .attr("stroke-width", 8.0)
                    .transition()
                    .duration(2000)
                    .delay(i * 180)
                    .ease(easeCubicOut)
                    .attr("stroke-dashoffset", 0)
                    .transition()
                    .delay(500)
                    .duration(1500)
                    .attr("fill", wardColor)
                    .attr(
                        "fill-opacity",
                        opacityScale(d.properties.total_population),
                    ) // Population-based transparency!
                    .attr("stroke", "rgba(255, 255, 255, 0.9)") // Final Ultra-Thick White borders
                    .attr("stroke-width", 8.0);
            });

            // Animate outer glow
            outerGlow
                .transition()
                .duration(1000)
                .delay((d, i) => i * 180 + 1500)
                .attr("opacity", 0.6)
                .on("end", enableInteractions); // Re-enable interactions after glow animation
        }

        // Enable interactions after animation is complete
        function enableInteractions() {
            g.selectAll(".ward-path").style("pointer-events", "all");
        }
        wards
            .on("mouseenter", function (event, d) {
                const currentColor = colorScale(d.properties.total_population);
                const wardIndex = wardsGeoJSON.features.indexOf(d);

                // Enhance the ward
                select(this)
                    .transition()
                    .duration(300)
                    .attr("fill-opacity", 0.95) // Brighter on hover
                    .attr("stroke", "rgba(255, 255, 255, 1)") // Pure white border
                    .attr("stroke-width", 10.0)
                    .style(
                        "filter",
                        "brightness(1.1) drop-shadow(0 0 20px rgba(242, 226, 93, 0.4))",
                    );

                // Enhance corresponding shadow
                select(shadows.nodes()[wardIndex])
                    .transition()
                    .duration(300)
                    .attr("opacity", 0.8)
                    .attr("transform", "translate(10, 15)");

                // Enhance corresponding glow
                select(outerGlow.nodes()[wardIndex])
                    .transition()
                    .duration(300)
                    .attr("opacity", 1)
                    .attr("stroke-width", 12);

                tooltip
                    .style("opacity", 1)
                    .select('[data-label="ward-name"]')
                    .text(d.properties.name_en || d.properties.name_ne);

                tooltip
                    .select('[data-label="population"]')
                    .text(
                        `Population: ${d.properties.total_population.toLocaleString()}`,
                    );
            })
            .on("mousemove", function (event) {
                const [x, y] = [event.pageX, event.pageY];
                tooltip
                    .style("left", x + 20 + "px")
                    .style("top", y - 20 + "px");
            })
            .on("mouseleave", function (event, d) {
                const wardIndex = wardsGeoJSON.features.indexOf(d);

                select(this)
                    .transition()
                    .duration(300)
                    .attr(
                        "fill-opacity",
                        opacityScale(d.properties.total_population),
                    )
                    .attr("stroke", "rgba(255, 255, 255, 0.9)")
                    .attr("stroke-width", 8.0)
                    .style("filter", "none");

                select(shadows.nodes()[wardIndex])
                    .transition()
                    .duration(300)
                    .attr("opacity", 1)
                    .attr("transform", "translate(8, 12)");

                select(outerGlow.nodes()[wardIndex])
                    .transition()
                    .duration(300)
                    .attr("opacity", 0.6)
                    .attr("stroke-width", 8);

                tooltip.style("opacity", 0);
            });

        // Scroll Trigger
        const observer = new IntersectionObserver(
            (entries) => {
                if (entries[0].isIntersecting) {
                    console.log("Map is visible, starting animation");
                    runAnimation();
                    observer.unobserve(container);
                }
            },
            { threshold: 0.25 },
        );

        observer.observe(container);

        console.log("âœ… Map initialization complete");
    }

    // Handle Astro Page Load/Transitions
    document.addEventListener("astro:page-load", () => {
        initMap();
    });

    // Initialize on first load
    if (document.readyState === "complete") {
        initMap();
    } else {
        window.addEventListener("load", initMap);
    }
</script>
<style>
    #population-map {
        /* Flat 2D map */
        filter: drop-shadow(0 10px 15px rgba(0, 0, 0, 0.3));
    }

    #population-map-container {
        /* No perspective needed for 2D */
        overflow: hidden;
    }

    .ward-path {
        transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
    }
</style>
